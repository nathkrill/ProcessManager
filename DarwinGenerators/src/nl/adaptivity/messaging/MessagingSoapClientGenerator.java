package nl.adaptivity.messaging;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Path;

import javax.jws.WebMethod;
import javax.jws.WebParam;
import javax.xml.namespace.QName;


public class MessagingSoapClientGenerator {

  /**
   * @param args
   */
  public static void main(String[] args) {
    String pkg=null;
    String outClass = null;
    String inClass = null;
    String srcdir = ".";
    String dstdir = ".";
    for(int i = 0; i<args.length; ++i) {
      switch (args[i]) {
        case "-package": {
          if (pkg!=null) { showHelp(); return; }
          pkg = args[++i];
          break;
        }
        case "-out": {
          if (outClass!=null) { showHelp(); return; }
          outClass = args[++i];
          int j = outClass.lastIndexOf('.');
          if (j>=0 && pkg==null) {
            pkg = outClass.substring(0, j);
            outClass = outClass.substring(j+1);
          }
          break;
        }
        case "-srcdir": {
          if (srcdir!=null) { showHelp(); return; }
          srcdir = args[i];
          break;
        }
        case "-dstdir": {
          if (dstdir!=null) { showHelp(); return; }
          dstdir = args[i];
          break;
        }
        case "-help": {
          showHelp();
          return;
        }
        default: {
          if (args[i].charAt(0)=='-' || inClass!=null) {
            showHelp();
            return;
          } else {
            inClass = args[i];
          }
        }
      }
    }
    if (inClass==null || outClass==null || pkg==null) {
      showHelp();
      return;
    }
    FileSystem fs = FileSystems.getDefault();

    String pkgdir = pkg.replaceAll("\\.", fs.getSeparator());
    String classfilename = outClass+".java";
    Path outfile = fs.getPath(srcdir, pkgdir, classfilename);

    URLClassLoader urlclassloader;
    try {
      urlclassloader = URLClassLoader.newInstance(new URL[] { fs.getPath(srcdir).toUri().toURL()});
    } catch (MalformedURLException e) {
      e.printStackTrace();
      return;
    }

    Class<?> endpointClass;
    try {
      endpointClass = urlclassloader.loadClass(inClass);
    } catch (ClassNotFoundException e) {
      e.printStackTrace();
      return;
    }
    String pkgname = pkg.replaceAll(fs.getSeparator(), ".");
    try {
      generateJava(outfile, endpointClass, pkgname, outClass);
    } catch (IOException e) {
      e.printStackTrace();
      return;
    }

  }

  private static void showHelp() {
    System.out.println("Usage:");
    System.out.println("  -help              : Show this message, ignore everything else");
    System.out.println("  -out <classname>   : The output classname to generate");
    System.out.println("  -package <pkgname> : The output package name to generate");
    System.out.println("  -srcdir <dirname>  : The directory to start looking for sources");
    System.out.println("  -dstdir <dirname>  : The directory to write the generated java files");
    System.out.println("  <inputclass>       : The Endpoint that needs a client");
  }

  private static void generateJava(Path pOutfile, Class<?> pEndpointClass, String pPkgname, String pOutClass) throws IOException {
    Writer out = new BufferedWriter(new FileWriter(pOutfile.toFile()));
    try {
      generateJava(out, pEndpointClass, pPkgname, pOutClass);
    } finally {
      out.close();
    }
  }

  private static void generateJava(Writer pOut, Class<?> pEndpointClass, String pPkgname, String pOutClass) throws IOException {
    pOut.write("/*\n");
    pOut.write(" * Generated by MessagingSoapClientGenerator.\n");
    pOut.write(" */\n\n");

    pOut.write("package "); pOut.write(pPkgname); pOut.write("\n\n");

    pOut.write("import nl.adaptivity.messaging.MessagingRegistry\n\n");
    pOut.write("import java.net.URI\n\n");
    pOut.write("import javax.xml.namespace.QName\n\n");

    pOut.write("public class "); pOut.write(pOutClass); pOut.write(" {\n\n");

    // Write service location constants / variables.
    boolean finalService = false;
    try {
      Endpoint instance = (Endpoint) pEndpointClass.newInstance();

      pOut.write(appendString(new StringBuilder("  private static final QName SERVICE = "),qnamestring(instance.getServiceName())).append(";\n").toString());
      pOut.write(appendString(new StringBuilder("  private static final String ENDPOINT = "),instance.getEndpointName()).append(";\n").toString());
      if (instance.getEndpointLocation()!=null) {
        pOut.write(appendString(new StringBuilder("  private static final URI LOCATION = URI.create("),instance.getEndpointLocation().toString()).append(");\n\n").toString());
      } else {
        pOut.write("  private static final URI LOCATION = null;\n\n");
      }
      finalService = true;
    } catch (ClassCastException e) {
    } catch (InstantiationException e) {
    } catch (IllegalAccessException e) {
      e.printStackTrace();
      System.exit(1);
    }
    if (!finalService) {
      pOut.write("  private static QName SERVICE = null;\n");
      pOut.write("  private static String ENDPOINT = null;\n");
      pOut.write("  private static URI LOCATION = null;\n\n");
    }

    // Constructor
    pOut.write("  private "); pOut.write(pOutClass); pOut.write(" { /* */ }\n\n");

    writeMethods(pOut, pEndpointClass);


    // Initializer in case we can't figure out the locations
    if (!finalService) {
      pOut.write("  private static void init(QName service, String endpoint, URI location) {\n");
      pOut.write("    SERVICE=service;\n");
      pOut.write("    ENDPOINT=endpoint;\n");
      pOut.write("    LOCATION=location;\n");
      pOut.write("  }\n\n");
    }

    pOut.write("}\n");
  }

  private static void writeMethods(Writer pOut, Class<?> pEndpointClass) throws IOException {
    for(Method method:pEndpointClass.getMethods()) {
      WebMethod annotation = method.getAnnotation(WebMethod.class);
      if (annotation!=null) {
        writeMethod(pOut, method, annotation);
      }
    }
  }

  private static void writeMethod(Writer pOut, Method pMethod, WebMethod pAnnotation) throws IOException {
    String methodName = pAnnotation.operationName();
    if (methodName==null) { methodName = pMethod.getName(); }
    pOut.write("public static Future<");
    pOut.write(pMethod.getReturnType().getCanonicalName());
    pOut.write("> "); pOut.write(methodName); pOut.write("(");
    boolean firstParam  = true;
    int paramNo = 0;
    for(Class<?> paramType: pMethod.getParameterTypes()) {
      String name = "param"+paramNo;
      for(Annotation annotation: pMethod.getParameterAnnotations()[paramNo]) {
        if (annotation instanceof WebParam) {
          WebParam webparam = (WebParam) annotation;
          if (webparam.name()!=null) {
            name = webparam.name();
          }
        }

      }

      ++paramNo;
    }


  }

  private static String qnamestring(QName pQName) {
    StringBuilder result = new StringBuilder();
    new QName(pQName.getNamespaceURI(), pQName.getLocalPart(), pQName.getPrefix());

    result.append("new QName(");
    appendString(result, pQName.getNamespaceURI()).append(',');
    appendString(result, pQName.getLocalPart());
    if (pQName.getPrefix()!=null) {
      appendString(result.append(','),pQName.getPrefix());
    }
    result.append(')');
    return result.toString();
  }

  private static StringBuilder appendString(StringBuilder pResult, String pString) {
    if (pString==null) {
      pResult.append("null");
    } else {
      pResult.append('"');
      for(int i=0; i<pString.length(); ++i) {
        char c = pString.charAt(i);
        switch (c) {
          case '\\':
            pResult.append("\\\\");
            break;
          case '"':
            pResult.append('\\').append(c);
            break;
          case '\t':
            pResult.append("\\t");
            break;
          case '\n':
            pResult.append("\\n");
            break;
          case '\r':
            pResult.append("\\r");
            break;
        }
      }
      pResult.append('"');
    }
    return pResult;
  }

}

/*
 * Copyright (c) 2016.
 *
 * This file is part of ProcessManager.
 *
 * ProcessManager is free software: you can redistribute it and/or modify it under the terms of version 3 of the
 * GNU Lesser General Public License as published by the Free Software Foundation.
 *
 * ProcessManager is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with Foobar.  If not,
 * see <http://www.gnu.org/licenses/>.
 */

//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2009.08.27 at 08:15:55 PM CEST
//


package nl.adaptivity.process.processModel;

import net.devrieze.util.StringUtil;
import net.devrieze.util.Transaction;
import nl.adaptivity.process.ProcessConsts.Engine;
import nl.adaptivity.process.engine.PETransformer;
import nl.adaptivity.process.engine.ProcessData;
import nl.adaptivity.process.engine.processModel.IProcessNodeInstance;
import nl.adaptivity.util.xml.*;
import nl.adaptivity.xml.XmlException;
import nl.adaptivity.xml.XmlReader;
import nl.adaptivity.xml.XmlWriter;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.w3c.dom.NodeList;

import javax.xml.namespace.QName;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;

import java.sql.SQLException;


@XmlDeserializer(XmlDefineType.Factory.class)
public class XmlDefineType extends XPathHolder implements IXmlDefineType {

  public static class Factory implements XmlDeserializerFactory<XmlDefineType> {

    @NotNull
    @Override
    public XmlDefineType deserialize(@NotNull final XmlReader in) throws XmlException {
      return XmlDefineType.deserialize(in);
    }
  }

  public static final String ELEMENTLOCALNAME = "define";
  public static final QName ELEMENTNAME = new QName(Engine.NAMESPACE, ELEMENTLOCALNAME, Engine.NSPREFIX);

  private String refNode;

  private String refName;

  public XmlDefineType() {}

  public XmlDefineType(final String name, final String refNode, final String refName, final String path, final char[] content, final Iterable<Namespace> originalNSContext) {
    super(content, originalNSContext, path, name);
    this.refNode = refNode;
    this.refName = refName;
  }

  @NotNull
  public static XmlDefineType deserialize(@NotNull final XmlReader in) throws XmlException {
    return deserialize(in, new XmlDefineType());
  }

  @NotNull
  @Override
  public QName getElementName() {
    return ELEMENTNAME;
  }

  @Override
  public boolean deserializeAttribute(final CharSequence attributeNamespace, @NotNull final CharSequence attributeLocalName, final CharSequence attributeValue) {
    switch (attributeLocalName.toString()) {
      case "refnode": setRefNode(StringUtil.toString(attributeValue)); return true;
      case "refname": setRefName(StringUtil.toString(attributeValue)); return true;
      default:
        return super.deserializeAttribute(attributeNamespace, attributeLocalName, attributeValue);
    }
  }

  @Override
  protected void serializeStartElement(@NotNull final XmlWriter out) throws XmlException {
    XmlUtil.writeStartElement(out, new QName(Engine.NAMESPACE, ELEMENTLOCALNAME, Engine.NSPREFIX));
  }

  @Override
  protected void serializeEndElement(@NotNull final XmlWriter out) throws XmlException {
    XmlUtil.writeEndElement(out, new QName(Engine.NAMESPACE, ELEMENTLOCALNAME, Engine.NSPREFIX));
  }

  @Override
  protected void serializeAttributes(@NotNull final XmlWriter out) throws XmlException {
    super.serializeAttributes(out);
    XmlUtil.writeAttribute(out, "refnode", getRefNode());
    XmlUtil.writeAttribute(out, "refname", getRefName());
  }

  /* (non-Javadoc)
     * @see nl.adaptivity.process.processModel.IXmlDefineType#getRefNode()
     */
  @Override
  public String getRefNode() {
    return refNode;
  }

  /* (non-Javadoc)
   * @see nl.adaptivity.process.processModel.IXmlDefineType#setRefNode(String)
   */
  @Override
  public void setRefNode(final String value) {
    this.refNode = value;
  }

  /* (non-Javadoc)
   * @see nl.adaptivity.process.processModel.XmlImportType#getName()
   */
  @Override
  public String getRefName() {
    return refName;
  }

  /* (non-Javadoc)
   * @see nl.adaptivity.process.processModel.XmlImportType#setName(java.lang.String)
   */
  @Override
  public void setRefName(final String value) {
    this.refName = value;
  }

  /**
   *
   * @param export
   * @return
   */
  @NotNull
  public static XmlDefineType get(final IXmlDefineType export) {
    if (export instanceof XmlDefineType) { return (XmlDefineType) export; }
    return new XmlDefineType(export.getName(), export.getRefNode(), export.getRefName(), export.getPath(), export.getContent(), export.getOriginalNSContext());
  }

  @Nullable
  @Override
  public <T extends IProcessNodeInstance<T>> ProcessData apply(final Transaction transaction, @NotNull final IProcessNodeInstance<T> node) throws SQLException {
    final ProcessData processData;
    if (refNode!=null) {
      final IProcessNodeInstance<T> predecessor = node.getPredecessor(transaction, refNode);
      final ProcessData origpair = predecessor.getResult(transaction, refName);
      if (origpair==null) {
        processData = null;
      } else {
        try {
          if (getXPath()==null) {
            processData = new ProcessData(getName(), origpair.getContent());
          } else {
            processData = new ProcessData(getName(), XmlUtil.nodeListToFragment((NodeList) getXPath().evaluate(origpair.getContentFragment(), XPathConstants.NODESET)));
          }
        } catch (@NotNull XPathExpressionException|XmlException e) {
          throw new RuntimeException(e);
        }
      }
    } else {
      processData = null;
    }
    final char[] content = getContent();
    if (getContent()!=null && getContent().length>0) {
      try {
        final PETransformer transformer = PETransformer.create(SimpleNamespaceContext.from(getOriginalNSContext()), processData);

        XmlReader reader = transformer.createFilter(getBodyStreamReader());
        final CompactFragment transformed = XmlUtil.siblingsToFragment(reader);
        return new ProcessData(getName(), transformed);

      } catch (@NotNull final XmlException e) {
        throw new RuntimeException(e);
      }
    } else {
      return processData;
    }
  }

}

//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2009.08.27 at 08:15:55 PM CEST
//


package nl.adaptivity.process.processModel;

import nl.adaptivity.process.ProcessConsts.Engine;
import nl.adaptivity.process.engine.PETransformer;
import nl.adaptivity.process.engine.ProcessData;
import nl.adaptivity.process.processModel.XmlResultType.Adapter;
import nl.adaptivity.process.processModel.XmlResultType.Factory;
import nl.adaptivity.process.util.Constants;
import nl.adaptivity.util.xml.*;
import org.w3c.dom.*;

import javax.xml.XMLConstants;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
import javax.xml.namespace.NamespaceContext;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;
import javax.xml.transform.dom.DOMSource;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;

import java.util.Map;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;


/**
 * <p>
 * Java class for ImportType complex type.
 * <p>
 * The following schema fragment specifies the expected content contained within
 * this class.
 *
 * <pre>
 * &lt;complexType name="ImportType">
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;attribute name="name" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />
 *       &lt;attribute name="path" type="{http://www.w3.org/2001/XMLSchema}string" />
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 */
//@XmlAccessorType(XmlAccessType.NONE)
//@XmlType(name = "ResultType")
@XmlJavaTypeAdapter(Adapter.class)
@XmlDeserializer(Factory.class)
public class XmlResultType extends XPathHolder implements IXmlResultType, XmlSerializable {

  public static class Adapter extends JAXBUnmarshallingAdapter {
    public Adapter() { super(XmlResultType.class); }
  }

  public static class Factory implements XmlDeserializerFactory {

    @Override
    public XmlResultType deserialize(final XMLStreamReader in) throws XMLStreamException {
      if (in.getEventType()!= XMLStreamConstants.START_ELEMENT) { in.nextTag(); }
      XmlResultType result = new XmlResultType();
      Map<String, String> namespaceMap = new TreeMap<>();
      for(int i=in.getAttributeCount()-1; i>=0;--i) {
        String prefix = in.getAttributePrefix(i);
        if (prefix==null || XMLConstants.DEFAULT_NS_PREFIX.equals(prefix)) {
          switch(in.getAttributeLocalName(i)) {
            case "name":
              result.name = in.getAttributeValue(i);
              break;
            case "path":
            case "xpath":
              result.setPath(in.getAttributeValue(i));
              break;
            case XMLConstants.XMLNS_ATTRIBUTE:
              break;
            default:
              Logger.getAnonymousLogger().log(Level.FINER, "Unsupported attribute in result: "+in.getAttributeName(i), in);
          }
        } else if (! XMLConstants.XMLNS_ATTRIBUTE.equals(prefix)) {
          Logger.getAnonymousLogger().log(Level.FINER, "Unsupported attribute in result: "+in.getAttributeName(i), in);
        }
      }

      String path = result.getPath();
      if (path!=null) {

        for(int i = in.getNamespaceCount()-1; i>=0; --i) {
          namespaceMap.put(in.getNamespacePrefix(i), in.getNamespaceURI(i));
        }

        try {
          addXpathUsedPrefixes(namespaceMap, path, in.getNamespaceContext());
        } catch (XPathExpressionException e) {
          throw new RuntimeException(e);
        }
      }
      while (in.getEventType()!=XMLStreamConstants.END_ELEMENT && in.hasNext()) {
        switch (in.next()) {
          case XMLStreamConstants.START_ELEMENT:
            DocumentFragment documentFragment = XmlUtil.childrenToDocumentFragment(in, result);
            result.content = documentFragment;
            break;
          default:
        }
      }

      if (result.content!=null) {
        try {
          addUsedPrefixes(in.getNamespaceContext(), namespaceMap, result.content);
        } catch (XPathExpressionException e) {
          throw new XMLStreamException(e);
        }
      }

      if (! (in.getEventType()==XMLStreamConstants.END_ELEMENT|| in.getEventType()==XMLStreamConstants.END_DOCUMENT)) {
        throw new RuntimeException("Missing end tag");
      }


      if (namespaceMap.size()>0) {
        result.setNamespaceContext(new SimpleNamespaceContext(namespaceMap));
      }
      return result;
    }

    private static void addUsedPrefixes(NamespaceContext pNamespaceContext, final Map<String, String> pCollectingMap, final Node pContent) throws
            XPathExpressionException {
      for(Node child=pContent.getFirstChild(); child!=null; child=child.getNextSibling()) {
        if (child instanceof Element) {
          Element elem = (Element) child;

          String xpath = null;

          Map<String,String> additionalPrefixes = new TreeMap<>();
          NamedNodeMap attributes = elem.getAttributes();
          for(int i=attributes.getLength()-1;i>=0; --i) {
            Attr a = (Attr) attributes.item(i);
            if (! (a.getNamespaceURI()==null ||
                    XMLConstants.NULL_NS_URI.equals(a.getNamespaceURI())||
                    a.getPrefix()==null ||
                    XMLConstants.DEFAULT_NS_PREFIX.equals(a.getPrefix())||
                    XMLConstants.XMLNS_ATTRIBUTE_NS_URI.equals(a.getNamespaceURI())||
                    XMLConstants.XML_NS_URI.equals(a.getNamespaceURI()))) {
              pCollectingMap.put(a.getPrefix(), a.getNamespaceURI());
            }
            if (XMLConstants.XMLNS_ATTRIBUTE.equals(a.getPrefix())) {
              additionalPrefixes.put(a.getLocalName(), a.getValue());
            } else if (XMLConstants.XMLNS_ATTRIBUTE.equals(a.getName())) {
              additionalPrefixes.put(XMLConstants.DEFAULT_NS_PREFIX, a.getValue());
            } else if (Constants.MODIFY_NS_STR.equals(elem.getNamespaceURI())) {
              if ("xpath".equals(a.getName())) {
                xpath = a.getValue();
              } else if (xpath!=null && "path".equals(a.getName())) {
                xpath = a.getValue();
              }
            }
          }

          NamespaceContext newContext = additionalPrefixes.size()>0 ? new CombiningNamespaceContext(new SimpleNamespaceContext(additionalPrefixes), pNamespaceContext): pNamespaceContext;

          if (! (elem.getNamespaceURI()==null || XMLConstants.NULL_NS_URI.equals(elem.getNamespaceURI()))) {
            pCollectingMap.put(elem.getPrefix(), elem.getNamespaceURI());
          }

          if (xpath!=null) {
            if (xpath.length()>1) {
              try {
                addXpathUsedPrefixes(pCollectingMap, xpath, newContext);
              } catch (Exception e) {
                Logger.getAnonymousLogger().log(Level.FINE, "Error with getting used namespaces from prefix", e);
              }
            }
          }

          addUsedPrefixes(newContext, pCollectingMap, elem);

        }
      }

    }

  }

  public static final String ELEMENTNAME = "result";

  private DocumentFragment content;

  private String name;

  public XmlResultType() {}

  public XmlResultType(String name, final String pPath, DocumentFragment content, NamespaceContext namespaceContext) {
    this.name=name;
    this.content=content;
    setPath(pPath);
    setNamespaceContext(namespaceContext);
  }

  @Override
  public void serialize(final XMLStreamWriter out) throws XMLStreamException {
    String prefix = out.getPrefix(Engine.NAMESPACE);
    if (prefix==null && getNamespaceContext()!=null) {
      prefix = getNamespaceContext().getPrefix(Engine.NAMESPACE);
    }
    if (prefix==null) {
      prefix = Engine.NSPREFIX;
    }
    out.writeStartElement(prefix, ELEMENTNAME, nl.adaptivity.process.ProcessConsts.Engine.NAMESPACE);
    serializeAttributes(out);
    if (content!=null && content.hasChildNodes()) {
      XmlUtil.serialize(out, new DOMSource(content));
    }
  }

  @Override
  void serializeAttributes(final XMLStreamWriter out) throws XMLStreamException {
    if (name!=null) {
      out.writeAttribute("name", name);
    }
  }

  /* (non-Javadoc)
     * @see nl.adaptivity.process.processModel.IXmlResultType#getContent()
     */
  @Override
  public DocumentFragment getContent() {
    return this.content;
  }

  /* (non-Javadoc)
   * @see nl.adaptivity.process.processModel.IXmlResultType#getName()
   */
  @Override
  public String getName() {
    return name;
  }

  /* (non-Javadoc)
   * @see nl.adaptivity.process.processModel.IXmlResultType#setName(java.lang.String)
   */
  @Override
  public void setName(final String value) {
    this.name = value;
  }

  public static XmlResultType get(IXmlResultType pImport) {
    if (pImport instanceof XmlResultType) { return (XmlResultType) pImport; }
    XmlResultType result = new XmlResultType(pImport.getName(), pImport.getPath(), null, pImport.getNamespaceContext());
    return result;
  }

  /**
   * Transform the given payload as specified by tag.
   * @param pPayload
   * @return
   */
  @Override
  public ProcessData apply(Node pPayload) {
    // TODO add support for variable and function resolvers.
    try {
      // shortcircuit missing path
      Node resultNode = (getPath()==null || ".".equals(getPath())) ? pPayload : (Node) getXPath().evaluate(pPayload, XPathConstants.NODE);
      ProcessData processData = new ProcessData(name, resultNode);
      if (content!=null && content.hasChildNodes()) {
        DocumentFragment result = PETransformer.create(getNamespaceContext(), processData).transform(content);
        return new ProcessData(name, result);
      } else {
        return processData;
      }


    } catch (XPathExpressionException e) {
      throw new RuntimeException(e);
    }
  }

}

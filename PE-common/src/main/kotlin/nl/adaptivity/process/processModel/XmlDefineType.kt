/*
 * Copyright (c) 2017.
 *
 * This file is part of ProcessManager.
 *
 * ProcessManager is free software: you can redistribute it and/or modify it under the terms of version 3 of the
 * GNU Lesser General Public License as published by the Free Software Foundation.
 *
 * ProcessManager is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with ProcessManager.  If not,
 * see <http://www.gnu.org/licenses/>.
 */

//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2009.08.27 at 08:15:55 PM CEST
//


package nl.adaptivity.process.processModel

import net.devrieze.util.StringUtil
import nl.adaptivity.process.ProcessConsts.Engine
import nl.adaptivity.xml.*
import java.util.*
import javax.xml.namespace.QName


@XmlDeserializer(XmlDefineType.Factory::class)
class XmlDefineType : XPathHolder, IXmlDefineType {

  class Factory : XmlDeserializerFactory<XmlDefineType> {

    @Throws(XmlException::class)
    override fun deserialize(reader: XmlReader): XmlDefineType {
      return XmlDefineType.deserialize(reader)
    }
  }


  @ProcessModelDSL
  class Builder {

    var name: String? = null
    var path: String? = null
    var content: CharArray
    var nsContext: MutableList<Namespace>

    internal constructor() {
      name = null
      path = null
      content = CharArray(0)
      nsContext = ArrayList<Namespace>()
    }

    internal constructor(orig: IXmlResultType) {
      name = orig.getName()
      path = orig.getPath()
      content = Arrays.copyOf(orig.content!!, orig.content!!.size)
      nsContext = ArrayList<Namespace>()
      val origContext = orig.getOriginalNSContext()
      if (origContext != null) {
        for (ns in origContext) {
          nsContext.add(ns)
        }
      }
    }

    fun build(): XmlResultType {
      return XmlResultType(name, path, content, nsContext)
    }
  }

  private var _refNode: String? = null

  private var _refName: String? = null

  constructor() {}

  constructor(name: String?,
              refNode: String?,
              refName: String?,
              path: String?,
              content: CharArray?,
              originalNSContext: Iterable<Namespace>) : super(content, originalNSContext, path,
                                                                     name) {
    this._refNode = refNode
    this._refName = refName
  }

  override val elementName: QName
    get() = ELEMENTNAME

  override fun deserializeAttribute(attributeNamespace: CharSequence,
                                    attributeLocalName: CharSequence,
                                    attributeValue: CharSequence): Boolean {
    when (attributeLocalName.toString()) {
      "refnode" -> {
        setRefNode(StringUtil.toString(attributeValue))
        return true
      }
      "refname" -> {
        setRefName(StringUtil.toString(attributeValue))
        return true
      }
      else      -> return super.deserializeAttribute(attributeNamespace, attributeLocalName, attributeValue)
    }
  }

  @Throws(XmlException::class)
  override fun serializeStartElement(out: XmlWriter) {
    out.smartStartTag(QName(Engine.NAMESPACE, ELEMENTLOCALNAME, Engine.NSPREFIX))
  }

  @Throws(XmlException::class)
  override fun serializeEndElement(out: XmlWriter) {
    out.endTag(QName(Engine.NAMESPACE, ELEMENTLOCALNAME, Engine.NSPREFIX))
  }

  @Throws(XmlException::class)
  override fun serializeAttributes(out: XmlWriter) {
    super.serializeAttributes(out)
    out.writeAttribute("refnode", getRefNode())
    out.writeAttribute("refname", getRefName())
  }

  /* (non-Javadoc)
     * @see nl.adaptivity.process.processModel.IXmlDefineType#getRefNode()
     */
  override fun getRefNode(): String? {
    return _refNode
  }

  /* (non-Javadoc)
   * @see nl.adaptivity.process.processModel.IXmlDefineType#setRefNode(String)
   */
  override fun setRefNode(value: String?) {
    this._refNode = value
  }

  /* (non-Javadoc)
   * @see nl.adaptivity.process.processModel.XmlImportType#getName()
   */
  override fun getRefName(): String? {
    return _refName
  }

  /* (non-Javadoc)
   * @see nl.adaptivity.process.processModel.XmlImportType#setName(java.lang.String)
   */
  override fun setRefName(value: String?) {
    this._refName = value
  }

  companion object {


    val ELEMENTLOCALNAME = "define"
    val ELEMENTNAME = QName(Engine.NAMESPACE, ELEMENTLOCALNAME, Engine.NSPREFIX)

    @Throws(XmlException::class)
    fun deserialize(reader: XmlReader): XmlDefineType {
      return XPathHolder.deserialize(reader, XmlDefineType())
    }

    @Deprecated("Use normal factory method", ReplaceWith("XmlDefineType(import)", "nl.adaptivity.process.processModel.XmlDefineType"))
    operator fun get(export: IXmlDefineType) = XmlDefineType(export)
  }
}


fun XmlDefineType(export:IXmlDefineType): XmlDefineType {
  if (export is XmlDefineType) {
    return export
  }
  return XmlDefineType(export.getName(), export.getRefNode(), export.getRefName(), export.getPath(), export.content,
                       export.getOriginalNSContext()?: emptyList<Namespace>())
}
/*
 * Copyright (c) 2016. 
 *
 * This file is part of ProcessManager.
 *
 * ProcessManager is free software: you can redistribute it and/or modify it under the terms of version 3 of the 
 * GNU Lesser General Public License as published by the Free Software Foundation.
 *
 * ProcessManager is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with Foobar.  If not,
 * see <http://www.gnu.org/licenses/>.
 */

//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2009.08.27 at 08:15:55 PM CEST
//


package nl.adaptivity.process.processModel

import nl.adaptivity.process.ProcessConsts.Engine
import nl.adaptivity.process.engine.PETransformer
import nl.adaptivity.process.engine.ProcessData
import nl.adaptivity.xml.XmlSerializable
import nl.adaptivity.util.xml.*
import nl.adaptivity.xml.SimpleNamespaceContext
import nl.adaptivity.xml.*
import nl.adaptivity.xml.Namespace
import org.w3c.dom.DocumentFragment
import org.w3c.dom.Node
import org.w3c.dom.NodeList

import javax.xml.namespace.QName
import javax.xml.xpath.XPathConstants
import javax.xml.xpath.XPathExpressionException


@XmlDeserializer(XmlResultType.Factory::class)
class XmlResultType : XPathHolder, IXmlResultType, XmlSerializable {

  class Factory : XmlDeserializerFactory<XmlResultType> {

    @Throws(XmlException::class)
    override fun deserialize(reader: XmlReader): XmlResultType {
      return XmlResultType.deserialize(reader)
    }

  }

  @ProcessModelDSL
  class Builder {

    var name: String?
    var path: String?
    var content: CharArray
    val nsContext: MutableList<Namespace>

    constructor() {
      name = null
      path = null
      content = CharArray(0)
      nsContext = mutableListOf<Namespace>()
    }

    constructor(orig: IXmlResultType) {
      name = orig.name
      path = orig.path
      content = orig.content.copyOf()
      nsContext = orig.originalNSContext?.toMutableList() ?: mutableListOf()
    }

    fun build(): XmlResultType {
      return XmlResultType(name, path, content, nsContext)
    }
  }

  @Deprecated("")
  constructor(): super()

  @Deprecated("")
  constructor(name: String, path: String, content: DocumentFragment?, namespaceContext: Iterable<nl.adaptivity.xml.Namespace>)
      : this(name, path, content?.let{ DomUtil.toString(it).toCharArray() }, namespaceContext)

  constructor(name: String?, path: String?, content: CharArray?, originalNSContext: Iterable<Namespace>)
      : super(content, originalNSContext, path, name)

  @Throws(XmlException::class)
  override fun serializeStartElement(out: XmlWriter) {
    out.smartStartTag(ELEMENTNAME)
  }

  @Throws(XmlException::class)
  override fun serializeEndElement(out: XmlWriter) {
    out.endTag(ELEMENTNAME)
  }

  override val elementName: QName
    get() = ELEMENTNAME

  /**
   * Transform the given payload as specified by tag.
   * @param payload
   * *
   * @return
   */
  override fun apply(payload: Node?): ProcessData {
    // TODO add support for variable and function resolvers.
    try {
      // shortcircuit missing path
      if (payload==null) { return ProcessData(name, CompactFragment("")) }
      val processData = if (path == null || "." == path) {
        ProcessData(name, DomUtil.nodeToFragment(payload))
      } else {
        ProcessData(name, DomUtil.nodeListToFragment(xPath!!.evaluate(DomUtil.ensureAttached(payload), XPathConstants.NODESET) as NodeList))
      }
      val content = content
      if (content != null && content.isNotEmpty()) {
        val transformer = PETransformer.create(SimpleNamespaceContext.from(originalNSContext), processData)
        val reader = transformer.createFilter(bodyStreamReader)

        if (reader.hasNext()) reader.next() // Initialise the reader

        val transformed = reader.siblingsToFragment()
        return ProcessData(name, transformed)
      } else {
        return processData
      }


    } catch (e: XPathExpressionException) {
      throw RuntimeException(e)
    } catch (e: XmlException) {
      throw RuntimeException(e)
    }

  }

  companion object {

    @JvmStatic
    @Throws(XmlException::class)
    fun deserialize(reader: XmlReader): XmlResultType {
      return XPathHolder.deserialize(reader, XmlResultType())
    }

    val ELEMENTLOCALNAME = "result"
    private val ELEMENTNAME = QName(Engine.NAMESPACE, ELEMENTLOCALNAME, Engine.NSPREFIX)

    @JvmStatic
    operator fun get(pImport: IXmlResultType): XmlResultType {
      if (pImport is XmlResultType) {
        return pImport
      }
      val originalNSContext: Iterable<Namespace> = pImport.originalNSContext?: emptyList()
      return XmlResultType(pImport.name, pImport.path, null as CharArray, originalNSContext)
    }
  }

}

/*
 * Copyright (c) 2018.
 *
 * This file is part of ProcessManager.
 *
 * ProcessManager is free software: you can redistribute it and/or modify it under the terms of version 3 of the 
 * GNU Lesser General Public License as published by the Free Software Foundation.
 *
 * ProcessManager is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with ProcessManager.  If not,
 * see <http://www.gnu.org/licenses/>.
 */

//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2009.08.27 at 08:15:55 PM CEST
//


package nl.adaptivity.process.processModel

import nl.adaptivity.process.ProcessConsts.Engine
import nl.adaptivity.process.engine.ProcessData
import nl.adaptivity.xml.*


@XmlDeserializer(XmlResultType.Factory::class)
class XmlResultType : XPathHolder, IXmlResultType, XmlSerializable {

  class Factory : XmlDeserializerFactory<XmlResultType> {

    override fun deserialize(reader: XmlReader): XmlResultType {
      return Companion.deserialize(reader)
    }

  }

  @ProcessModelDSL
  class Builder {

    var name: String?
    var path: String?
    var content: CharArray?
    val nsContext: MutableList<Namespace>

    constructor() {
      name = null
      path = null
      content = CharArray(0)
      nsContext = mutableListOf<Namespace>()
    }

    constructor(orig: IXmlResultType) {
      name = orig.getName()
      path = orig.getPath()
      content = orig.content?.copyOf()
      nsContext = orig.originalNSContext.toMutableList()
    }

    fun build(): XmlResultType {
      return XmlResultType(name, path, content, nsContext)
    }
  }

  @Deprecated("Use one of the parameterized constructors")
  constructor(): super()

  constructor(name: String?, path: String?, content: CharArray?, originalNSContext: Iterable<Namespace>)
      : super(content, originalNSContext, path, name)

  override fun serializeStartElement(out: XmlWriter) {
    out.smartStartTag(ELEMENTNAME)
  }

  override fun serializeEndElement(out: XmlWriter) {
    out.endTag(ELEMENTNAME)
  }

  override val elementName: QName
    get() = ELEMENTNAME

/*
  */
/**
   * Transform the given payload as specified by tag.
   * @param payload
   *
   * @return
   *//*

  override fun applyData(payload: Node?): ProcessData {
    // TODO add support for variable and function resolvers.
    try {
      // shortcircuit missing path
      if (payload==null) { return ProcessData(getName(), CompactFragment(""))
      }
      val processData = if (getPath() == null || "" == getPath()) {
          ProcessData(getName(), DomUtil.nodeToFragment(payload))
      } else {
          ProcessData(getName(), DomUtil.nodeListToFragment(
              xPath!!.evaluate(DomUtil.ensureAttached(payload), XPathConstants.NODESET) as NodeList))
      }
      val content = content
      if (content?.isNotEmpty() ?: false) {
        val transformer = PETransformer.create(SimpleNamespaceContext.from(originalNSContext), processData)
        val reader = transformer.createFilter(bodyStreamReader)

        if (reader.hasNext()) reader.next() // Initialise the reader

        val transformed = reader.siblingsToFragment()
        return ProcessData(getName(), transformed)
      } else {
        return processData
      }


    } catch (e: XPathExpressionException) {
      throw RuntimeException(e)
    } catch (e: XmlException) {
      throw RuntimeException(e)
    }

  }
*/

  companion object {

    fun deserialize(reader: XmlReader): XmlResultType {
      return deserialize(reader, XmlResultType())
    }

    val ELEMENTLOCALNAME = "result"
    private val ELEMENTNAME = QName(Engine.NAMESPACE,
                                    ELEMENTLOCALNAME, Engine.NSPREFIX)

    @Deprecated("Use normal factory method", ReplaceWith("XmlResultType(import)", "nl.adaptivity.process.processModel.XmlResultType"))
    operator fun get(import: IXmlResultType) = XmlResultType(import)
  }

}

fun XmlResultType(import: IXmlResultType): XmlResultType {
  if (import is XmlResultType) {
    return import
  }
  val originalNSContext: Iterable<Namespace> = import.originalNSContext
  return XmlResultType(import.getName(), import.getPath(), content = null,
                                                          originalNSContext = originalNSContext)
}